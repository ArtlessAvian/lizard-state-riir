use crate::positional::RelativePosition;
use crate::tiles::Direction;
use crate::tiles::Grid;
use crate::tiles::PlanarProjection;

/// An element of the free group generated by UP and RIGHT.
///
/// Example: U R U' R'
/// (Of course, DOWN is the inverse of UP, and LEFT is the inverse of RIGHT.)
/// Note that this element is NOT EQUAL to the empty string element.
/// Nothing commutes.
///
/// This is the densest possible grid structure.
/// The diameter of this space with 32 bits is 20 or so.
///
/// This struct should be able to represent (3^10 - 3) * 4 strings.
/// Which is more than enough, haha.
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
#[must_use]
struct FreeGroup {
    bit_pattern: u32,
}

impl FreeGroup {
    // Each direction takes three bits.
    const MASK: u32 = 0b111;

    // Any direction ^ INVERSE gives its inverse.
    const INVERSE: u32 = 0b111;

    // Each direction is nonzero.
    const UP: u32 = 0b001;
    const RIGHT: u32 = 0b010;
    const DOWN: u32 = Self::INVERSE ^ Self::UP;
    const LEFT: u32 = Self::INVERSE ^ Self::RIGHT;

    fn new_empty() -> Self {
        Self { bit_pattern: 0 }
    }

    fn get_position(self) -> RelativePosition {
        let mut dx = 0;
        let mut dy = 0;
        let mut to_consume = self.bit_pattern;
        while (to_consume & Self::MASK) != 0 {
            match to_consume & Self::MASK {
                Self::UP => dy += 1,
                Self::DOWN => dy -= 1,
                Self::RIGHT => dx += 1,
                Self::LEFT => dx -= 1,
                _ => panic!("unexpected bit pattern! {}", to_consume & Self::MASK),
            }
            to_consume >>= 3;
        }

        RelativePosition { dx, dy }
    }
}

impl Grid for FreeGroup {
    type NeighborType = Self;

    fn go(&self, dir: Direction) -> Option<Self::NeighborType> {
        let pattern = match dir {
            Direction::Up => Self::UP,
            Direction::Down => Self::DOWN,
            Direction::Left => Self::LEFT,
            Direction::Right => Self::RIGHT,
        };

        if self.bit_pattern & Self::MASK == pattern ^ Self::INVERSE {
            Some(FreeGroup {
                bit_pattern: self.bit_pattern >> 3,
            })
        } else {
            if self.bit_pattern > (u32::MAX >> 3) {
                return None;
            }
            Some(FreeGroup {
                bit_pattern: pattern | self.bit_pattern << 3,
            })
        }
    }
}

impl PlanarProjection for FreeGroup {
    fn project_coords(&self) -> (i32, i32) {
        let mut dx = 0;
        let mut dy = 0;
        let mut to_consume = self.bit_pattern;
        while (to_consume & Self::MASK) != 0 {
            match to_consume & Self::MASK {
                Self::UP => dy += 1,
                Self::DOWN => dy -= 1,
                Self::RIGHT => dx += 1,
                Self::LEFT => dx -= 1,
                _ => panic!("unexpected bit pattern! {}", to_consume & Self::MASK),
            }
            to_consume >>= 3;
        }
        (dx, dy)
    }
}

#[cfg(test)]
mod test {
    use super::FreeGroup;
    use super::Grid;
    use crate::positional::RelativePosition;

    #[test]
    fn inverses_cancel() {
        assert_eq!(
            FreeGroup::new_empty().up().down(),
            Some(FreeGroup::new_empty())
        );
        assert_eq!(
            FreeGroup::new_empty().down().up(),
            Some(FreeGroup::new_empty())
        );
        assert_eq!(
            FreeGroup::new_empty().left().right(),
            Some(FreeGroup::new_empty())
        );
        assert_eq!(
            FreeGroup::new_empty().right().left(),
            Some(FreeGroup::new_empty())
        );
    }

    #[test]
    fn not_commutative() {
        assert_ne!(
            FreeGroup::new_empty().up().right(),
            FreeGroup::new_empty().right().up()
        );
        assert_ne!(
            FreeGroup::new_empty().up().left(),
            FreeGroup::new_empty().left().up()
        );
        assert_ne!(
            FreeGroup::new_empty().down().right(),
            FreeGroup::new_empty().right().down()
        );
        assert_ne!(
            FreeGroup::new_empty().down().left(),
            FreeGroup::new_empty().left().down()
        );
    }

    #[test]
    fn projection() {
        use super::Direction::*;

        let mut element = FreeGroup::new_empty();
        let mut expected = RelativePosition::new(0, 0);
        assert_eq!(element.get_position(), expected);
        for dir in [Up, Right, Down, Left, Right, Up, Left, Down] {
            element = element.go(dir).unwrap();
            match dir {
                Up => expected = expected + RelativePosition::new(0, 1),
                Down => expected = expected + RelativePosition::new(0, -1),
                Left => expected = expected + RelativePosition::new(-1, 0),
                Right => expected = expected + RelativePosition::new(1, 0),
            }
            assert_eq!(element.get_position(), expected);
        }
    }

    #[test]
    #[should_panic(expected = "unwrap")]
    fn not_infinite() {
        // unfortunately.
        let mut element = FreeGroup::new_empty();
        for _ in 0..32 {
            element = element.up().unwrap();
        }
    }

    #[test]
    fn almost_full() {
        // This value is meaningless.
        let element = FreeGroup {
            bit_pattern: u32::MAX >> 3,
        };
        assert!(element.up().is_some());
    }
}
