// use core::ops::Deref;

// use crate::direction::Direction;
// use crate::path::bits_backed::PathBitString;
// use crate::tiling::HasSquareTiling;
// use crate::tiling::IsATile;

// pub mod impl_isagroup;

// /// A string with canceling inverses.
// #[derive(Debug, Clone, Copy, PartialEq, Eq)]
// #[must_use]
// pub struct FreeGroupElement(PathBitString);

// impl FreeGroupElement {
//     const fn new() -> Self {
//         Self(PathBitString::new())
//     }

//     #[must_use]
//     pub const fn append_cancel(self, dir: Direction) -> Option<Self> {
//         if let Ok((init, last)) = self.0.pop()
//             && dir.inverse().const_eq(last)
//         {
//             return Some(Self(init));
//         }

//         match self.0.push(dir) {
//             Some(x) => Some(Self(x)),
//             None => None,
//         }
//     }
// }

// impl Deref for FreeGroupElement {
//     type Target = PathBitString;

//     fn deref(&self) -> &Self::Target {
//         &self.0
//     }
// }

// impl IsATile for FreeGroupElement {}

// /// The free group, generated by two elements.
// #[derive(Default, Clone, Copy, PartialEq, Eq)]
// pub struct FreeGroup;

// impl HasSquareTiling<FreeGroupElement> for FreeGroup {
//     fn get_origin(&self) -> FreeGroupElement {
//         FreeGroupElement::new()
//     }

//     fn step(&self, tile: &FreeGroupElement, dir: Direction) -> Option<FreeGroupElement>
//     where
//         FreeGroupElement: Clone,
//     {
//         tile.append_cancel(dir)
//     }
// }

// #[cfg(test)]
// mod tests {
//     use crate::direction::Direction;
//     use crate::free_group::FreeGroup;
//     use crate::free_group::FreeGroupElement;
//     use crate::tiling::HasSquareTiling;

//     #[test]
//     fn space_traversal() {
//         let origin = FreeGroup.get_origin();

//         let up_right_down_left = FreeGroup.skip_path(
//             &origin,
//             [
//                 Direction::Up,
//                 Direction::Right,
//                 Direction::Down,
//                 Direction::Left,
//             ],
//         );

//         assert_ne!(up_right_down_left, Ok(origin));
//         assert!(up_right_down_left.is_ok());
//     }

//     #[test]
//     fn string_append() {
//         let empty = FreeGroupElement::new();
//         assert!(empty.is_empty());
//         assert_eq!(empty.len(), 0);

//         let right = empty.append_cancel(Direction::Right).unwrap();
//         assert!(!right.is_empty());
//         assert_eq!(right.len(), 1);

//         let right_left = right.append_cancel(Direction::Left).unwrap();
//         assert!(right_left.is_empty());
//         assert_eq!(right_left.len(), 0);

//         let right_left_left = right_left.append_cancel(Direction::Left).unwrap();
//         assert!(!right_left_left.is_empty());
//         assert_eq!(right_left_left.len(), 1);
//     }

//     #[test]
//     fn string_iter() {
//         let path = [
//             Direction::Right,
//             Direction::Right,
//             Direction::Left,
//             Direction::Down,
//             Direction::Down,
//         ];

//         let string = path
//             .into_iter()
//             .try_fold(FreeGroupElement::new(), |string, dir| {
//                 FreeGroupElement::append_cancel(string, dir)
//             })
//             .unwrap();

//         let mut iter = string.into_iter();
//         for expected in [Direction::Right, Direction::Down, Direction::Down] {
//             assert_eq!(iter.next().unwrap(), expected);
//         }
//         assert_eq!(iter.next(), None);
//     }

//     #[test]
//     fn string_overflow() {
//         let mut string = FreeGroupElement::new();

//         for _ in 0..28 {
//             string = string.append_cancel(Direction::Right).unwrap();
//         }

//         assert!(string.append_cancel(Direction::Right).is_none());
//     }
// }
