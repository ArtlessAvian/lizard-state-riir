use core::ops::Deref;

use crate::group::GroupOp;
use crate::path::PathBitString;
use crate::tiling::Direction;
use crate::tiling::HasSquareTiling;
use crate::tiling::Tile;

/// The free group, generated by two elements.
#[derive(Default, Clone, Copy, PartialEq, Eq)]
pub struct FreeGroup;

impl HasSquareTiling<FreeGroupElement> for FreeGroup {
    fn get_origin(&self) -> FreeGroupElement {
        FreeGroupElement::new()
    }

    fn go(&self, tile: &FreeGroupElement, dir: Direction) -> Option<FreeGroupElement>
    where
        FreeGroupElement: Clone,
    {
        tile.append_cancel(dir)
    }
}

/// A string with canceling inverses.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[must_use]
pub struct FreeGroupElement(PathBitString);

impl FreeGroupElement {
    const fn new() -> Self {
        Self(PathBitString::new())
    }

    #[must_use]
    pub const fn append_cancel(self, dir: Direction) -> Option<Self> {
        if let Some((init, last)) = self.0.pop()
            && dir.inverse().const_eq(last)
        {
            return Some(Self(init));
        }

        match self.0.append(dir) {
            Some(x) => Some(Self(x)),
            None => None,
        }
    }
}

impl Deref for FreeGroupElement {
    type Target = PathBitString;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl Tile for FreeGroupElement {}

pub struct FreeGroupConcat;

impl GroupOp for FreeGroupConcat {
    type Element = FreeGroupElement;

    const IDENTITY: Self::Element = FreeGroupElement::new();
    const UP: Self::Element = FreeGroupElement::new()
        .append_cancel(Direction::Up)
        .unwrap();
    const RIGHT: Self::Element = FreeGroupElement::new()
        .append_cancel(Direction::Right)
        .unwrap();

    fn inverse(&self, a: &Self::Element) -> Self::Element {
        FreeGroupElement(a.inverse())
    }

    fn op(&self, a: &Self::Element, b: &Self::Element) -> Option<Self::Element> {
        let mut ab = *a;
        for element in b.iter() {
            ab = ab.append_cancel(element)?;
        }
        Some(ab)
    }
}

#[cfg(test)]
mod tests {
    use crate::free_group::FreeGroup;
    use crate::free_group::FreeGroupConcat;
    use crate::free_group::FreeGroupElement;
    use crate::group::GroupOp;
    use crate::tiling::Direction;
    use crate::tiling::HasSquareTiling;
    use crate::tiling::PathHelper;

    #[test]
    fn space_traversal() {
        let origin = FreeGroup.get_origin();

        let up_right_down_left = FreeGroup.skip_path(
            &origin,
            [
                Direction::Up,
                Direction::Right,
                Direction::Down,
                Direction::Left,
            ]
            .into_iter(),
        );

        assert_ne!(up_right_down_left, Ok(origin));
        assert!(up_right_down_left.is_ok());
    }

    #[test]
    fn string_append() {
        let empty = FreeGroupElement::new();
        assert!(empty.is_empty());
        assert_eq!(empty.len(), 0);

        let right = empty.append_cancel(Direction::Right).unwrap();
        assert!(!right.is_empty());
        assert_eq!(right.len(), 1);

        let right_left = right.append_cancel(Direction::Left).unwrap();
        assert!(right_left.is_empty());
        assert_eq!(right_left.len(), 0);

        let right_left_left = right_left.append_cancel(Direction::Left).unwrap();
        assert!(!right_left_left.is_empty());
        assert_eq!(right_left_left.len(), 1);
    }

    #[test]
    fn string_iter() {
        let path = [
            Direction::Right,
            Direction::Right,
            Direction::Left,
            Direction::Down,
            Direction::Down,
        ];

        let string = path
            .into_iter()
            .try_fold(FreeGroupElement::new(), |string, dir| {
                FreeGroupElement::append_cancel(string, dir)
            })
            .unwrap();

        let mut iter = string.iter();
        for expected in [Direction::Right, Direction::Down, Direction::Down] {
            assert_eq!(iter.next().unwrap(), expected);
        }
        assert_eq!(iter.next(), None);
    }

    #[test]
    fn string_overflow() {
        let mut string = FreeGroupElement::new();

        for _ in 0..29 {
            string = string.append_cancel(Direction::Right).unwrap();
        }

        assert!(string.append_cancel(Direction::Right).is_none());
    }

    #[test]
    fn group_basics() {
        for el in [
            FreeGroupConcat::IDENTITY,
            FreeGroupConcat::UP,
            FreeGroupConcat::RIGHT,
        ] {
            assert_eq!(
                FreeGroupConcat.op(&el, &FreeGroupConcat.inverse(&el)),
                Some(FreeGroupConcat::IDENTITY)
            );

            assert_eq!(
                FreeGroupConcat.op(&FreeGroupConcat.inverse(&el), &el),
                Some(FreeGroupConcat::IDENTITY)
            );
        }
    }

    #[test]
    fn group_inverse() {
        let path = [
            Direction::Up,
            Direction::Right,
            Direction::Down,
            Direction::Left,
            Direction::Left,
            Direction::Down,
            Direction::Right,
            Direction::Up,
        ];

        let string = FreeGroup
            .skip_path(&FreeGroupElement::new(), path.into_iter())
            .unwrap();

        assert_eq!(
            FreeGroupConcat.op(&string, &FreeGroupConcat.inverse(&string)),
            Some(FreeGroupConcat::IDENTITY)
        );

        assert_eq!(
            FreeGroupConcat.op(&FreeGroupConcat.inverse(&string), &string),
            Some(FreeGroupConcat::IDENTITY)
        );
    }
}
