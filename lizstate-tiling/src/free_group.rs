use core::result::Result;

use crate::tiling_graph::CanFindArbitraryPath;
use crate::tiling_graph::IsASpace;
use crate::tiling_graph::IsATile;
use crate::tiling_graph::IsTilingGraph;
use crate::tiling_graph::IsWalkable;
use crate::tiling_graph::StepError;
use crate::walk::reduced::Reduced;
use crate::walk::reduced::ReducedWalkEnum;
use crate::walk::traits::IsAWalk;
use crate::walk::traits::IsAWalkPartial;
use crate::walk::traits::IsAWalkRaw;

/// A reduced "word" formed from the alphabet Up, Right, and their inverses.
///
/// Which is pretty much just a reduced path.
/// Notably, elements of the free group are 1-1 with reduced words.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[must_use]
pub struct FreeGroupWord(ReducedWalkEnum);

impl IsATile for FreeGroupWord {}

/// The free group generated by Up and Right.
///
/// We don't really *care* that this is a group.
/// We aren't doing group operations.
pub struct TheFreeGroup;

impl IsASpace for TheFreeGroup {}

impl IsTilingGraph for TheFreeGroup {
    type Tile = FreeGroupWord;

    fn get_origin(&self) -> Self::Tile {
        FreeGroupWord(ReducedWalkEnum::new_empty())
    }

    fn step(
        &self,
        tile: &Self::Tile,
        dir: crate::direction::Direction,
    ) -> Result<Self::Tile, StepError> {
        tile.0
            .push_copy(dir)
            .map(FreeGroupWord)
            .map_err(|_| StepError::DestinationUnrepresentable)
    }
}

impl IsWalkable for TheFreeGroup {}

impl CanFindArbitraryPath for TheFreeGroup {
    fn path_from_origin<Walk: IsAWalkRaw>(
        &self,
        to: &Self::Tile,
    ) -> Result<Reduced<Walk>, Walk::PushError> {
        Reduced::<Walk>::try_new_from_iter(to.0)
    }
}

#[cfg(test)]
mod tests {
    use crate::direction::Direction;
    use crate::free_group::TheFreeGroup;
    use crate::tiling_graph::IsTilingGraph;
    use crate::tiling_graph::IsWalkable;

    #[test]
    fn space_traversal() {
        let origin = TheFreeGroup.get_origin();

        let up_right_down_left = TheFreeGroup.walk_from_origin([
            Direction::Up,
            Direction::Right,
            Direction::Down,
            Direction::Left,
        ]);

        assert_ne!(up_right_down_left.unwrap(), origin);
    }
}
