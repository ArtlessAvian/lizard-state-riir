// hmm yes i enjoy this code
// TODO: replace when upcasting is stable in rust.

// For any dyn traits generated by rkyv.

use std::rc::Rc;

use super::ActionTrait;
use super::CommandTrait;
use super::DirectionActionTrait;
use super::SerializeActionTrait;
use super::SerializeCommandTrait;
use super::SerializeDirectionActionTrait;
use super::SerializeTileActionTrait;
use super::TileActionTrait;
use crate::entity::EntityId;
use crate::floor::Floor;
use crate::floor::FloorUpdate;
use crate::positional::AbsolutePosition;
use crate::positional::RelativePosition;

#[derive(Debug, Clone)]
pub struct Upcast<T: ?Sized>(Rc<T>);

impl<T: ?Sized> Upcast<T> {
    pub fn new(contents: Rc<T>) -> Self {
        Upcast(contents)
    }
}

impl ActionTrait for Upcast<dyn SerializeActionTrait> {
    fn verify_action(&self, floor: &Floor, subject_id: EntityId) -> Option<Box<dyn CommandTrait>> {
        self.0.verify_action(floor, subject_id)
    }
}

impl TileActionTrait for Upcast<dyn SerializeTileActionTrait> {
    fn verify_action(
        &self,
        floor: &Floor,
        subject_id: EntityId,
        tile: AbsolutePosition,
    ) -> Option<Box<dyn CommandTrait>> {
        self.0.verify_action(floor, subject_id, tile)
    }
}

impl DirectionActionTrait for Upcast<dyn SerializeDirectionActionTrait> {
    fn verify_action(
        &self,
        floor: &Floor,
        subject_id: EntityId,
        dir: RelativePosition,
    ) -> Option<Box<dyn CommandTrait>> {
        self.0.verify_action(floor, subject_id, dir)
    }
}

impl CommandTrait for Upcast<dyn SerializeCommandTrait> {
    fn do_action(&self, floor: &Floor) -> FloorUpdate {
        self.0.do_action(floor)
    }

    fn get_tile_hints(&self, floor: &Floor) -> Vec<AbsolutePosition> {
        self.0.get_tile_hints(floor)
    }
}
