// Due to the enum dispatch macro, this file containing the traits needs to know the implementors referenced in the enum.
#![allow(clippy::wildcard_imports)]

pub mod utils;

pub mod example;

// TOOD: move to data, which should also be renamed floor/gamestate.
pub mod events;

/// Publicly exposed actions, free to construct.
pub mod public;

/// Actions to give to entities on creation. Access through `Entity::get_actions()`.
///
/// TODO: Move to dependent crate?
/// TODO: Ensure entity "owns" the action before creating command.
pub mod characters;

/// Enum of crate actions and commands also implementing rkyv traits.
///
/// The enums are "known" to the crate. This also avoids the overloaded "(de)serialize(able)" term.
///
/// # Serialization
/// Since each element of the enums also implement rkyv traits, then the enum itself can.
/// This is purely for ergonomics, avoiding boilerplate around the `rkyv_dyn` crate.
/// External crates are encouraged to write their own static dispatch enum and only implement the `rkyv_dyn` crate for that.
pub mod known_serializable;

use std::fmt::Debug;
use std::rc::Rc;

use enum_dispatch::enum_dispatch;
use rkyv::Archive;
use rkyv::Deserialize;
use rkyv::Serialize;
use rkyv_dyn::archive_dyn;

use self::characters::axolotl_nano::*;
use self::characters::max_tegu::*;
use self::events::FloorEvent;
use self::example::*;
use self::known_serializable::*;
use self::public::*;
use crate::entity::EntityId;
use crate::floor::Floor;
use crate::floor::FloorUpdate;
use crate::positional::AbsolutePosition;
use crate::positional::RelativePosition;

// Rc to allow cloning trait objects, also its cheap!
#[derive(Debug, Clone)]
pub enum UnaimedAction {
    None(Rc<dyn ActionTrait>),
    Tile(Rc<dyn TileActionTrait>),
    Direction(Rc<dyn DirectionActionTrait>),
}

/// An action, something that someone could do. Who and when is not defined.
///
/// Sort of like a dry run. If this returned floors immediately, it would be "most correct"
/// but also create a lot of allocations.
///
/// A generic flow.
/// ```rust
/// use std::rc::Rc;
/// use engine::actions::*;
/// use engine::floor::*;
/// use engine::entity::*;
/// fn context(action: Box<dyn ActionTrait>, floor: &Floor, player_id: EntityId) -> FloorUpdate {
///     let command = action.verify_action(floor, player_id).unwrap();
///     command.do_action(floor)
/// }
/// ```
///
/// TODOs
/// * Some indicator of an infallible action?
/// * Maybe create another trait to describe an UnaimedAction? Currently you construct an action with the aiming built in.
///   This would involve yet more type erasure. You would know what UnaimedAction you have, but you would forget when you aim it.
///     * Consider ordering? First converting Unaimed to Aimed, then converting to Command (with Entity) is a bit awkward.
///       Binding entity first makes more sense but requires twice as many traits (unbound -> unaimed -> command).
/// * Alternatively, create an enum with all the options of `Box<dyn Trait>`? If you know the type, then no problem, parse into a command normally.
///   If you don't (since its in the enum), match from enum and run targeting logic in each arm. Having only one conversion means all the validation is in one place.
///   There's not likely to be some absurd targeting type not already defined.
/// * Consider if subject should **always** the floor's next turn taker.
/// * If not, can actions/commands call each other?

#[archive_dyn(deserialize)]
#[enum_dispatch(KnownAction)]
pub trait ActionTrait: Debug {
    fn verify_action(&self, floor: &Floor, subject_id: EntityId) -> Option<Box<dyn CommandTrait>>;
}

#[archive_dyn(deserialize)]
#[enum_dispatch(KnownTileAction)]
pub trait TileActionTrait: Debug {
    fn verify_action(
        &self,
        floor: &Floor,
        subject_id: EntityId,
        tile: AbsolutePosition,
    ) -> Option<Box<dyn CommandTrait>>;
}

#[archive_dyn(deserialize)]
#[enum_dispatch(KnownDirectionAction)]
pub trait DirectionActionTrait: Debug {
    fn verify_action(
        &self,
        floor: &Floor,
        subject_id: EntityId,
        dir: RelativePosition,
    ) -> Option<Box<dyn CommandTrait>>;
}

/// Someone, doing something, in some context. Can panic!
///
/// If there is an error, it is not the user's fault. So panicking is fine.
///
/// Unfortunately the context is not stored, so you have to pass it back in again. Which leads to:
/// TODO: Figure out lifetime shenanigans, so Commands live shorter than Actions.
/// You shouldn't need to store a command, you just do it.
/// If you must, you store the action that produced it.

// Not *everything* that is a command needs to be a SerializeCommandTrait (generated by #[archive_dyn]).
// Don't do it if you don't need it, its more work and more boilerplate.
// (Also note that Actions don't return them. It is not likely that the user is verifying an action and immediately serializing it.)
// (A dyn SerializeCommandTrait is probably generated by other Commands.)
#[archive_dyn(deserialize)]
#[enum_dispatch(KnownCommand)]
pub trait CommandTrait: Debug {
    fn do_action(&self, floor: &Floor) -> FloorUpdate;
}

/// An action that never verifies to a command.
///
/// This is preferable to a no-op command, since that would produce a new Floor.
#[derive(Debug, Archive, Serialize, Deserialize)]
#[archive_attr(derive(Debug))]
pub struct NullAction {}

impl ActionTrait for NullAction {
    fn verify_action(&self, _: &Floor, _: EntityId) -> Option<Box<dyn CommandTrait>> {
        None
    }
}
