pub mod utils;

pub mod example;

pub mod upcast_indirection;

// TOOD: move to data, which should also be renamed floor/gamestate.
pub mod events;

/// Publicly exposed actions, free to construct.
pub mod public;

pub mod characters;

use std::rc::Rc;

use std::fmt::Debug;

use rkyv::Archive;
use rkyv::Archived;
use rkyv::Deserialize;
use rkyv::Serialize;
use rkyv_dyn::archive_dyn;
use rkyv_typename::TypeName;

use crate::entity::Entity;
use crate::floor::Floor;
use crate::floor::FloorUpdate;
use crate::positional::AbsolutePosition;
use crate::positional::RelativePosition;

use self::events::FloorEvent;
use self::upcast_indirection::Upcast;

// Rc to allow cloning trait objects, also its cheap!
#[derive(Debug, Clone)]
pub enum UnaimedAction {
    None(Rc<dyn ActionTrait>),
    Tile(Rc<dyn TileActionTrait>),
    Direction(Rc<dyn DirectionActionTrait>),
}

// Same as above, but more specialized. Has an ugly conversion.
#[derive(Debug, Clone, Archive, Serialize, Deserialize)]
#[archive_attr(derive(Debug))]
pub enum SerializableAction {
    None(Rc<dyn SerializeActionTrait>),
    Tile(Rc<dyn SerializeTileActionTrait>),
    Direction(Rc<dyn SerializeDirectionActionTrait>),
}

impl From<SerializableAction> for UnaimedAction {
    fn from(value: SerializableAction) -> Self {
        // mmm yes i love indirection
        match value {
            SerializableAction::None(x) => UnaimedAction::None(Rc::new(Upcast::new(x))),
            SerializableAction::Tile(x) => UnaimedAction::Tile(Rc::new(Upcast::new(x))),
            SerializableAction::Direction(x) => UnaimedAction::Direction(Rc::new(Upcast::new(x))),
        }
    }
}

/// An action, something that someone could do. Who and when is not defined.
///
/// Sort of like a dry run. If this returned floors immediately, it would be "most correct"
/// but also create a lot of allocations.
///
/// A generic flow.
/// ```rust
/// use std::rc::Rc;
/// use engine::actions::*;
/// use engine::floor::*;
/// use engine::entity::*;
/// fn context(action: Box<dyn ActionTrait>, floor: &Floor, player_id: Rc<Entity>) -> FloorUpdate {
///     let command = action.verify_action(floor, &player_id).unwrap();
///     command.do_action(floor)
/// }
/// ```
///
/// TODOs
/// * Some indicator of an infallible action?
/// * Maybe create another trait to describe an UnaimedAction? Currently you construct an action with the aiming built in.
///   This would involve yet more type erasure. You would know what UnaimedAction you have, but you would forget when you aim it.
///     * Consider ordering? First converting Unaimed to Aimed, then converting to Command (with Entity) is a bit awkward.
///       Binding entity first makes more sense but requires twice as many traits (unbound -> unaimed -> command).
/// * Alternatively, create an enum with all the options of Box<dyn Trait>? If you know the type, then no problem, parse into a command normally.
///   If you don't (since its in the enum), match from enum and run targeting logic in each arm. Having only one conversion means all the validation is in one place.
///   There's not likely to be some absurd targeting type not already defined.
/// * Consider if subject should **always** the floor's next turn taker.
/// * If not, can actions/commands call each other?

#[archive_dyn(deserialize)]
pub trait ActionTrait: Debug {
    fn verify_action(
        &self,
        floor: &Floor,
        subject_ref: &Rc<Entity>,
    ) -> Option<Box<dyn CommandTrait>>;
}

#[archive_dyn(deserialize)]
pub trait TileActionTrait: Debug {
    fn verify_action(
        &self,
        floor: &Floor,
        subject_ref: &Rc<Entity>,
        tile: AbsolutePosition,
    ) -> Option<Box<dyn CommandTrait>>;
}

#[archive_dyn(deserialize)]
pub trait DirectionActionTrait: Debug {
    fn verify_action(
        &self,
        floor: &Floor,
        subject_ref: &Rc<Entity>,
        dir: RelativePosition,
    ) -> Option<Box<dyn CommandTrait>>;
}

/// Someone, doing something, in some context. Can panic!
///
/// If there is an error, it is not the user's fault. So panicking is fine.
///
/// Unfortunately the context is not stored, so you have to pass it back in again. Which leads to:
/// TODO: Figure out lifetime shenanigans, so Commands live shorter than Actions.
/// You shouldn't need to store a command, you just do it.
/// If you must, you store the action that produced it.

// Not *everything* that is a command needs to be a SerializeCommandTrait (generated by #[archive_dyn]).
// Don't do it if you don't need it, its more work and more boilerplate.
// (Also note that Actions don't return them. It is not likely that the user is verifying an action and immediately serializing it.)
// (A dyn SerializeCommandTrait is probably generated by other Commands.)
#[archive_dyn(deserialize)]
pub trait CommandTrait: Debug {
    fn do_action(&self, floor: &Floor) -> FloorUpdate;
}

/// An action that never verifies to a command.
///
/// This is preferable to a no-op command, since that would produce a new Floor.
#[derive(Debug, Archive, Serialize, Deserialize)]
#[archive_attr(derive(Debug, TypeName))]
pub struct NullAction {}

#[archive_dyn(deserialize)]
impl ActionTrait for NullAction {
    fn verify_action(&self, _: &Floor, _: &Rc<Entity>) -> Option<Box<dyn CommandTrait>> {
        None
    }
}

impl ActionTrait for Archived<NullAction> {
    fn verify_action(&self, _: &Floor, _: &Rc<Entity>) -> Option<Box<dyn CommandTrait>> {
        None
    }
}
